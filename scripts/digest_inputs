#!/usr/bin/env bash

source scripts/standard_header.bash

# This function exports environment variables to GITHUB_ENV
# so they can be used by future steps in the GitHub Actions job.
#
# It either calls 'forward_env' or 'set_env' for each one.
#
#   forward_env: Forwards the already-set value if it's already set
#                or sets it to a default value if provided
#                or results in an error if there's no value or
#   set_env:     Always sets the env to the specified value.
#
main() {

	# Pass through env vars from required action inputs.

	forward_env INSTRUCTIONS
	forward_env OS
	forward_env ARCH
	forward_env PRODUCT_VERSION
	forward_env PACKAGE_NAME

	# Pass through env vars from optional action inputs (or set to default value).

	forward_env BIN_NAME "$(remove_enterprise_suffix "$PACKAGE_NAME")"
	forward_env ZIP_NAME "${PACKAGE_NAME}_${PRODUCT_VERSION}_${OS}_${ARCH}.zip"
	
	# Set relative paths used to store various build artifacts.
	
	set_env TARGET_DIR "dist/$OS/$ARCH"
	set_env ZIP_DIR    "dist"
	set_env META_DIR   "dist/meta/$OS/$ARCH"
	set_env BIN_PATH   "$TARGET_DIR/$BIN_NAME"
	set_env ZIP_PATH   "$ZIP_DIR/$ZIP_NAME"

	# Set absolute paths for the primary and verification builds.

	set_env PRIMARY_BUILD_ROOT      "$(pwd)"
	set_env VERIFICATION_BUILD_ROOT "$(simplify_path "$PRIMARY_BUILD_ROOT/../verification")"
	
	# Gather contextual info from git.

	set_env PRODUCT_REVISION "$(git rev-parse HEAD)"
	set_env PRODUCT_REVISION_TIME "$(git show -s --format=%cI "$PRODUCT_REVISION")"
	set_env PRODUCT_REVISION_TIME_LOCAL "$(cut -d+ -f1 <<< "$PRODUCT_REVISION_TIME")"

	# Set Go-specific vars.

	set_env GOOS "$OS"
	set_env GOARCH "$ARCH"
}

# Run the main func after parsing the functions it relies on.
trap main EXIT

simplify_path() { realpath -Lsm "$1"; }

remove_enterprise_suffix() {
	echo "${1%-enterprise}"
}

export_to_github_job() { local NAME="$1"
	{
		echo "$NAME<<EOF"
		echo "${!NAME}"
		echo "EOF"
	} >> "$GITHUB_ENV"
	# For testing purposes we also write to a standard
	# script file we can source in the tests to see which
	# variables have been exported with which values.
	echo "export $NAME='${!NAME}'" >> "$GITHUB_ENV.export"
	log "Exported to GITHUB_ENV: $NAME='${!NAME}'"
}

# forward_env passes the current value of the named env var
# through to GitHub, or uses the default value if that variable
# is currently empty. If both are empty, it's an error.
forward_env() {
	local NAME="$1"
	local DEFAULT="${2:-}"
	export_env_or_default "$NAME" "$DEFAULT"
	export_to_github_job "$NAME"
}

# set_env sets an env var and preserves it for the 
set_env() {
	local NAME="$1"
	local VALUE="$2"
	export "$NAME"="$VALUE"
	export_env "$NAME"
	export_to_github_job "$NAME"
}

# export_env_or_default exports an env var with the name specified,
# if that variable is already nonempty, then its original value is
# preserved. If it is unset or empty, then it is set to the default
# value.
export_env_or_default() {
	local NAME="$1"
	local DEFAULT="${2:-}"
	# Already got a value? Just export it as that.
	try_export_nonempty "$NAME" && return
	# Default value provided? Export it with that value.
	test -n "$DEFAULT" && {
		export "$NAME"="$DEFAULT"
		return
	}
	err "Attempting to export an empty or unset env var with no default value."
}

export_env() {
	local NAME="$1"
	try_export_nonempty "$NAME" || err "Attempting to export an empty or unset env var."
}

try_export_nonempty() {
	local NAME="$1"
	test -n "${!NAME:-}" || return 1
	export "$NAME"="${!NAME}"
}
